{"/home/travis/build/npmtest/node-npmtest-openid-client/test.js":"/* istanbul instrument in package npmtest_openid_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-openid-client/lib.npmtest_openid_client.js":"/* istanbul instrument in package npmtest_openid_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_openid_client = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_openid_client = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-openid-client/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-openid-client && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_openid_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_openid_client\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_openid_client.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_openid_client.rollup.js'] =\n            local.assetsDict['/assets.npmtest_openid_client.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_openid_client.__dirname + '/lib.npmtest_openid_client.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-openid-client/node_modules/openid-client/lib/index.js":"'use strict';\n\nconst Issuer = require('./issuer');\nconst Registry = require('./issuer_registry');\nconst Strategy = require('./passport_strategy');\nconst TokenSet = require('./token_set');\n\nmodule.exports = {\n  Issuer,\n  Registry,\n  Strategy,\n  TokenSet,\n};\n","/home/travis/build/npmtest/node-npmtest-openid-client/node_modules/openid-client/lib/issuer.js":"'use strict';\n\nconst jose = require('node-jose');\nconst assert = require('assert');\nconst util = require('util');\nconst url = require('url');\nconst _ = require('lodash');\nconst LRU = require('lru-cache');\nconst got = require('got');\n\nconst DEFAULT_HTTP_OPTIONS = require('./consts').DEFAULT_HTTP_OPTIONS;\nconst ISSUER_DEFAULTS = require('./consts').ISSUER_DEFAULTS;\nconst DISCOVERY = require('./consts').DISCOVERY;\nconst WEBFINGER = require('./consts').WEBFINGER;\nconst REL = require('./consts').REL;\n\nconst errorHandler = require('./error_handler');\nconst BaseClient = require('./client');\nconst registry = require('./issuer_registry');\nconst expectResponse = require('./expect_response');\nconst webfingerNormalize = require('./webfinger_normalize');\n\nconst privateProps = new WeakMap();\n\nlet defaultHttpOptions = _.clone(DEFAULT_HTTP_OPTIONS);\n\nfunction instance(ctx) {\n  if (!privateProps.has(ctx)) privateProps.set(ctx, { metadata: {} });\n  return privateProps.get(ctx);\n}\n\nfunction stripTrailingSlash(uri) {\n  if (uri && uri.endsWith('/')) {\n    return uri.slice(0, -1);\n  }\n  return uri;\n}\n\nclass Issuer {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(metadata) {\n    const properties = Object.assign({}, ISSUER_DEFAULTS, metadata);\n\n    if (!properties.introspection_endpoint && properties.token_introspection_endpoint) {\n      properties.introspection_endpoint = properties.token_introspection_endpoint;\n    }\n\n    if (!properties.revocation_endpoint && properties.token_revocation_endpoint) {\n      properties.revocation_endpoint = properties.token_revocation_endpoint;\n    }\n\n    _.forEach(properties, (value, key) => {\n      instance(this).metadata[key] = value;\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() { return instance(this).metadata[key]; },\n        });\n      }\n    });\n\n    instance(this).cache = new LRU({ max: 100 });\n\n    registry.set(this.issuer, this);\n\n    const self = this;\n\n    Object.defineProperty(this, 'Client', {\n      value: class Client extends BaseClient {\n        static get issuer() {\n          return self;\n        }\n\n        get issuer() {\n          return this.constructor.issuer;\n        }\n      },\n    });\n  }\n\n  /**\n   * @name inspect\n   * @api public\n   */\n  inspect() {\n    return util.format('Issuer <%s>', this.issuer);\n  }\n\n  /**\n   * @name keystore\n   * @api private\n   */\n  keystore(reload) {\n    if (!this.jwks_uri) return Promise.reject(new Error('jwks_uri must be configured'));\n\n    const keystore = instance(this).keystore;\n    const lookupCache = instance(this).cache;\n\n    if (reload || !keystore) {\n      lookupCache.reset();\n      return got(this.jwks_uri, this.httpOptions())\n        .then(expectResponse(200))\n        .then(response => JSON.parse(response.body))\n        .then(jwks => jose.JWK.asKeyStore(jwks))\n        .then((joseKeyStore) => {\n          lookupCache.set('throttle', true, 60 * 1000);\n          instance(this).keystore = joseKeyStore;\n          return joseKeyStore;\n        })\n        .catch(errorHandler);\n    }\n\n    return Promise.resolve(keystore);\n  }\n\n  /**\n   * @name key\n   * @api private\n   */\n  key(def, allowMulti) {\n    const lookupCache = instance(this).cache;\n\n    // refresh keystore on every unknown key but also only upto once every minute\n    const freshJwksUri = lookupCache.get(def) || lookupCache.get('throttle');\n\n    return this.keystore(!freshJwksUri)\n      .then(store => store.all(def))\n      .then((keys) => {\n        assert(keys.length, 'no valid key found');\n        if (!allowMulti) {\n          assert.equal(keys.length, 1, 'multiple matching keys, kid must be provided');\n          lookupCache.set(def, true);\n        }\n        return keys[0];\n      });\n  }\n\n  /**\n   * @name metadata\n   * @api public\n   */\n  get metadata() {\n    return instance(this).metadata;\n  }\n\n  /**\n   * @name webfinger\n   * @api public\n   */\n  static webfinger(input) {\n    const resource = webfingerNormalize(input);\n    const host = url.parse(resource).host;\n    const query = { resource, rel: REL };\n    const opts = { query, followRedirect: true };\n    const webfingerUrl = `https://${host}${WEBFINGER}`;\n\n    return got(webfingerUrl, this.httpOptions(opts))\n      .then(expectResponse(200))\n      .then(response => JSON.parse(response.body))\n      .then((body) => {\n        const location = _.find(body.links, link => typeof link === 'object' && link.rel === REL && link.href);\n        assert(location, 'no issuer found in webfinger');\n        assert(typeof location.href === 'string' && location.href.startsWith('https://'), 'invalid issuer location');\n        const expectedIssuer = location.href;\n        if (registry.has(expectedIssuer)) return registry.get(expectedIssuer);\n\n        return this.discover(expectedIssuer).then((issuer) => {\n          try {\n            assert.equal(issuer.issuer, expectedIssuer, 'discovered issuer mismatch');\n          } catch (err) {\n            registry.delete(issuer.issuer);\n            throw err;\n          }\n          return issuer;\n        });\n      });\n  }\n\n  /**\n   * @name discover\n   * @api public\n   */\n  static discover(uri) {\n    uri = stripTrailingSlash(uri); // eslint-disable-line no-param-reassign\n    const isWellKnown = uri.endsWith(DISCOVERY);\n    const wellKnownUri = isWellKnown ? uri : `${uri}${DISCOVERY}`;\n\n    return got(wellKnownUri, this.httpOptions())\n      .then(expectResponse(200))\n      .then(response => new this(JSON.parse(response.body)))\n      .catch(errorHandler);\n  }\n\n  /**\n   * @name httpOptions\n   * @api public\n   */\n  httpOptions() {\n    return this.constructor.httpOptions.apply(this.constructor, arguments); // eslint-disable-line prefer-rest-params, max-len\n  }\n\n  /**\n   * @name httpOptions\n   * @api public\n   */\n  static httpOptions(values) {\n    return _.merge({}, this.defaultHttpOptions, values);\n  }\n\n  /**\n   * @name defaultHttpOptions\n   * @api public\n   */\n  static get defaultHttpOptions() {\n    return defaultHttpOptions;\n  }\n\n  /**\n   * @name defaultHttpOptions=\n   * @api public\n   */\n  static set defaultHttpOptions(value) {\n    defaultHttpOptions = _.merge({}, DEFAULT_HTTP_OPTIONS, value);\n  }\n\n}\n\nmodule.exports = Issuer;\n","/home/travis/build/npmtest/node-npmtest-openid-client/node_modules/openid-client/lib/consts.js":"const pkg = require('../package.json');\n\nconst USER_AGENT = `${pkg.name}/${pkg.version} (${pkg.homepage})`;\n\nconst DISCOVERY = '/.well-known/openid-configuration';\nconst WEBFINGER = '/.well-known/webfinger';\nconst REL = 'http://openid.net/specs/connect/1.0/issuer';\n\nconst CLIENT_DEFAULTS = {\n  application_type: ['web'],\n  grant_types: ['authorization_code'],\n  id_token_signed_response_alg: 'RS256',\n  response_types: ['code'],\n  token_endpoint_auth_method: 'client_secret_basic',\n};\n\nconst ISSUER_DEFAULTS = {\n  claims_parameter_supported: false,\n  grant_types_supported: ['authorization_code', 'implicit'],\n  request_parameter_supported: false,\n  request_uri_parameter_supported: true,\n  require_request_uri_registration: false,\n  response_modes_supported: ['query', 'fragment'],\n  token_endpoint_auth_methods_supported: ['client_secret_basic'],\n};\n\nconst CALLBACK_PROPERTIES = [\n  'access_token',\n  'code',\n  'error',\n  'error_description',\n  'expires_in',\n  'id_token',\n  'state',\n  'token_type',\n  'session_state',\n];\n\nconst DEFAULT_HTTP_OPTIONS = {\n  followRedirect: false,\n  headers: { 'User-Agent': USER_AGENT },\n  retries: 0,\n  timeout: 1500,\n};\n\nconst JWT_CONTENT = /^application\\/jwt/;\n\nmodule.exports.CALLBACK_PROPERTIES = CALLBACK_PROPERTIES;\nmodule.exports.CLIENT_DEFAULTS = CLIENT_DEFAULTS;\nmodule.exports.DEFAULT_HTTP_OPTIONS = DEFAULT_HTTP_OPTIONS;\nmodule.exports.ISSUER_DEFAULTS = ISSUER_DEFAULTS;\nmodule.exports.JWT_CONTENT = JWT_CONTENT;\nmodule.exports.USER_AGENT = USER_AGENT;\nmodule.exports.DISCOVERY = DISCOVERY;\nmodule.exports.REL = REL;\nmodule.exports.WEBFINGER = WEBFINGER;\n","/home/travis/build/npmtest/node-npmtest-openid-client/node_modules/openid-client/lib/error_handler.js":"'use strict';\n\nconst isStandardError = require('./is_standard_error');\nconst OpenIdConnectError = require('./open_id_connect_error');\n\nmodule.exports = function gotErrorHandler(err) {\n  if (isStandardError(err)) throw new OpenIdConnectError(err.response.body, err.response);\n  throw err;\n};\n","/home/travis/build/npmtest/node-npmtest-openid-client/node_modules/openid-client/lib/is_standard_error.js":"'use strict';\n\nconst got = require('got');\n\nmodule.exports = function isStandardError(error) {\n  if (error instanceof got.HTTPError) {\n    try {\n      error.response.body = JSON.parse(error.response.body);\n      return !!error.response.body.error;\n    } catch (err) {}\n  }\n\n  return false;\n};\n","/home/travis/build/npmtest/node-npmtest-openid-client/node_modules/openid-client/lib/open_id_connect_error.js":"'use strict';\n\nconst createErrorClass = require('create-error-class');\n\nmodule.exports = createErrorClass('OpenIdConnectError', function stdError(body, response) {\n  if (response) {\n    Object.defineProperty(this, 'response', {\n      value: response,\n    });\n  }\n  Object.assign(this, {\n    message: body.error,\n    error: body.error,\n    error_description: body.error_description,\n    state: body.state,\n    scope: body.scope,\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-openid-client/node_modules/openid-client/lib/client.js":"'use strict';\n\nconst util = require('util');\nconst assert = require('assert');\nconst http = require('http');\nconst crypto = require('crypto');\nconst querystring = require('querystring');\nconst jose = require('node-jose');\nconst uuid = require('uuid');\nconst base64url = require('base64url');\nconst url = require('url');\nconst _ = require('lodash');\nconst got = require('got');\nconst tokenHash = require('oidc-token-hash');\n\nconst errorHandler = require('./error_handler');\nconst expectResponse = require('./expect_response');\nconst TokenSet = require('./token_set');\nconst OpenIdConnectError = require('./open_id_connect_error');\nconst now = require('./unix_timestamp');\n\nconst CALLBACK_PROPERTIES = require('./consts').CALLBACK_PROPERTIES;\nconst CLIENT_DEFAULTS = require('./consts').CLIENT_DEFAULTS;\nconst JWT_CONTENT = require('./consts').JWT_CONTENT;\n\nconst issuerRegistry = require('./issuer_registry');\n\nconst map = new WeakMap();\nconst format = 'compact';\n\nfunction bearer(token) {\n  return `Bearer ${token}`;\n}\n\nfunction instance(ctx) {\n  if (!map.has(ctx)) map.set(ctx, { metadata: {} });\n  return map.get(ctx);\n}\n\n/* eslint-disable no-underscore-dangle */\nfunction cleanUpClaims(claims) {\n  if (_.isEmpty(claims._claim_names)) delete claims._claim_names;\n  if (_.isEmpty(claims._claim_sources)) delete claims._claim_sources;\n  return claims;\n}\n\nfunction assignClaim(target, source, sourceName) {\n  return (inSource, claim) => {\n    if (inSource === sourceName) {\n      assert(source[claim] !== undefined, `expected claim \"${claim}\" in \"${sourceName}\"`);\n      target[claim] = source[claim];\n      delete target._claim_names[claim];\n    }\n  };\n}\n/* eslint-enable no-underscore-dangle */\n\nfunction getFromJWT(jwt, position, claim) {\n  assert.equal(typeof jwt, 'string', 'invalid JWT type, expected a string');\n  const parts = jwt.split('.');\n  assert.equal(parts.length, 3, 'invalid JWT format, expected three parts');\n  const parsed = JSON.parse(base64url.decode(parts[position]));\n  return typeof claim === 'undefined' ? parsed : parsed[claim];\n}\n\nfunction getSub(jwt) {\n  return getFromJWT(jwt, 1, 'sub');\n}\n\nfunction getIss(jwt) {\n  return getFromJWT(jwt, 1, 'iss');\n}\n\nfunction getHeader(jwt) {\n  return getFromJWT(jwt, 0);\n}\n\nfunction getPayload(jwt) {\n  return getFromJWT(jwt, 1);\n}\n\nfunction assignErrSrc(sourceName) {\n  return (err) => {\n    err.src = sourceName;\n    throw err;\n  };\n}\n\nfunction authorizationParams(params) {\n  assert.equal(typeof params, 'object', 'you must provide an object');\n\n  const authParams = _.chain(params).defaults({\n    client_id: this.client_id,\n    scope: 'openid',\n    response_type: 'code',\n  }).forEach((value, key, object) => {\n    if (value === null || value === undefined) {\n      delete object[key];\n    } else if (key === 'claims' && typeof value === 'object') {\n      object[key] = JSON.stringify(value);\n    } else if (typeof value !== 'string') {\n      object[key] = String(value);\n    }\n  }).value();\n\n  assert(authParams.response_type === 'code' || authParams.nonce,\n    'nonce MUST be provided for implicit and hybrid flows');\n\n  return authParams;\n}\n\nfunction claimJWT(jwt) {\n  try {\n    const iss = getIss(jwt);\n    const keyDef = getHeader(jwt);\n    assert(keyDef.alg, 'claim source is missing JWT header alg property');\n\n    if (keyDef.alg === 'none') return Promise.resolve(getPayload(jwt));\n\n    const getKey = (() => {\n      if (!iss || iss === this.issuer.issuer) {\n        return this.issuer.key(keyDef);\n      } else if (issuerRegistry.has(iss)) {\n        return issuerRegistry.get(iss).key(keyDef);\n      }\n      return this.issuer.constructor.discover(iss).then(issuer => issuer.key(keyDef));\n    })();\n\n    return getKey\n      .then(key => jose.JWS.createVerify(key).verify(jwt))\n      .then(result => JSON.parse(result.payload));\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\n\nconst deprecatedKeystore = util.deprecate(keystore => keystore,\n  'passing keystore directly is deprecated, pass an object with keystore property instead');\n\nclass Client {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(metadata, keystore) {\n    const properties = Object.assign({}, CLIENT_DEFAULTS, metadata);\n\n    _.forEach(properties, (value, key) => {\n      instance(this).metadata[key] = value;\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() { return instance(this).metadata[key]; },\n        });\n      }\n    });\n\n    if (keystore !== undefined) {\n      assert(jose.JWK.isKeyStore(keystore), 'keystore must be an instance of jose.JWK.KeyStore');\n      instance(this).keystore = keystore;\n    }\n\n    if (this.token_endpoint_auth_method.endsWith('_jwt')) {\n      assert(this.issuer.token_endpoint_auth_signing_alg_values_supported,\n        'token_endpoint_auth_signing_alg_values_supported must be provided on the issuer');\n    }\n\n    this.CLOCK_TOLERANCE = 0;\n  }\n\n  /**\n   * @name authorizationUrl\n   * @api public\n   */\n  authorizationUrl(params) {\n    assert(this.issuer.authorization_endpoint, 'authorization_endpoint must be configured');\n    return url.format(_.defaults({\n      search: null,\n      query: authorizationParams.call(this, params),\n    }, url.parse(this.issuer.authorization_endpoint)));\n  }\n\n  /**\n   * @name authorizationPost\n   * @api public\n   */\n  authorizationPost(params) {\n    const inputs = authorizationParams.call(this, params);\n    const formInputs = Object.keys(inputs)\n      .map(name => `<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join('\\n');\n\n    return `<!DOCTYPE html>\n<head>\n  <title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n  <form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n    ${formInputs}\n  </form>\n</body>\n</html>`;\n  }\n\n  /**\n   * @name callbackParams\n   * @api public\n   */\n  callbackParams(input) { // eslint-disable-line\n    const isIncomingMessage = input instanceof http.IncomingMessage;\n    const isString = typeof input === 'string';\n\n    assert(isString || isIncomingMessage, '#callbackParams only accepts string urls or http.IncomingMessage');\n\n    let uri;\n    if (isIncomingMessage) {\n      const msg = input;\n\n      switch (msg.method) {\n        case 'GET':\n          uri = msg.url;\n          break;\n        case 'POST':\n          assert(msg.body, 'incoming message body missing, include a body parser prior to this call');\n          switch (typeof msg.body) {\n            case 'object':\n            case 'string':\n              if (Buffer.isBuffer(msg.body)) {\n                return querystring.parse(msg.body.toString('utf-8'));\n              } else if (typeof msg.body === 'string') {\n                return querystring.parse(msg.body);\n              }\n\n              return msg.body;\n            default:\n              throw new Error('invalid IncomingMessage body object');\n          }\n        default:\n          throw new Error('invalid IncomingMessage method');\n      }\n    } else {\n      uri = input;\n    }\n\n    return _.pick(url.parse(uri, true).query, CALLBACK_PROPERTIES);\n  }\n\n  /**\n   * @name authorizationCallback\n   * @api public\n   */\n  authorizationCallback(redirectUri, parameters, checks) {\n    const params = _.pick(parameters, CALLBACK_PROPERTIES);\n    const toCheck = checks || {};\n\n    if (this.default_max_age && !toCheck.max_age) toCheck.max_age = this.default_max_age;\n\n    if (toCheck.state !== parameters.state) {\n      return Promise.reject(new Error('state mismatch'));\n    }\n\n    if (params.error) {\n      return Promise.reject(new OpenIdConnectError(params));\n    }\n\n    let promise;\n\n    if (params.id_token) {\n      promise = Promise.resolve(new TokenSet(params))\n        .then(tokenset => this.decryptIdToken(tokenset, 'id_token'))\n        .then(tokenset => this.validateIdToken(tokenset, toCheck.nonce, 'authorization', toCheck.max_age));\n    }\n\n    if (params.code) {\n      const grantCall = () => this.grant({\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: toCheck.code_verifier,\n      })\n        .then(tokenset => this.decryptIdToken(tokenset, 'id_token'))\n        .then(tokenset => this.validateIdToken(tokenset, toCheck.nonce, 'token', toCheck.max_age))\n        .then((tokenset) => {\n          if (params.session_state) tokenset.session_state = params.session_state;\n          return tokenset;\n        });\n\n      if (promise) {\n        promise = promise.then(grantCall);\n      } else {\n        return grantCall();\n      }\n    }\n\n    return promise;\n  }\n\n  /**\n   * @name decryptIdToken\n   * @api private\n   */\n  decryptIdToken(token, use) {\n    if (\n      (use === 'userinfo' && !this.userinfo_encrypted_response_alg) ||\n      (use === 'id_token' && !this.id_token_encrypted_response_alg)\n    ) {\n      return Promise.resolve(token);\n    }\n\n    let idToken = token;\n\n    if (idToken instanceof TokenSet) {\n      /* istanbul ignore next */\n      if (!idToken.id_token) {\n        throw new Error('id_token not present in TokenSet');\n      }\n\n      idToken = idToken.id_token;\n    }\n\n    let expectedAlg;\n    let expectedEnc;\n\n    if (use === 'userinfo') {\n      expectedAlg = this.userinfo_encrypted_response_alg;\n      expectedEnc = this.userinfo_encrypted_response_enc;\n    } else {\n      expectedAlg = this.id_token_encrypted_response_alg;\n      expectedEnc = this.id_token_encrypted_response_enc;\n    }\n\n    const header = JSON.parse(base64url.decode(idToken.split('.')[0]));\n\n    assert.equal(header.alg, expectedAlg, 'unexpected alg received');\n    assert.equal(header.enc, expectedEnc, 'unexpected enc received');\n\n    const keystoreOrSecret = expectedAlg.match(/^(RSA|ECDH)/) ?\n      Promise.resolve(instance(this).keystore) : this.joseSecret(expectedAlg);\n\n    return keystoreOrSecret.then(keyOrStore => jose.JWE.createDecrypt(keyOrStore).decrypt(idToken)\n      .then((result) => {\n        if (token instanceof TokenSet) {\n          token.id_token = result.payload.toString('utf8');\n          return token;\n        }\n        return result.payload.toString('utf8');\n      }));\n  }\n\n  /**\n   * @name validateIdToken\n   * @api private\n   */\n  validateIdToken(tokenSet, nonce, returnedBy, maxAge) {\n    let idToken = tokenSet;\n\n    const expectedAlg = (() => {\n      if (returnedBy === 'userinfo') return this.userinfo_signed_response_alg;\n      return this.id_token_signed_response_alg;\n    })();\n\n    const isTokenSet = idToken instanceof TokenSet;\n\n    if (isTokenSet) {\n      if (!idToken.id_token) {\n        throw new Error('id_token not present in TokenSet');\n      }\n\n      idToken = idToken.id_token;\n    }\n\n    idToken = String(idToken);\n\n    const timestamp = now();\n    const parts = idToken.split('.');\n    const header = JSON.parse(base64url.decode(parts[0]));\n    const payload = JSON.parse(base64url.decode(parts[1]));\n\n    const verifyPresence = (prop) => {\n      if (payload[prop] === undefined) {\n        throw new Error(`missing required JWT property ${prop}`);\n      }\n    };\n\n    assert.equal(header.alg, expectedAlg, 'unexpected algorithm received');\n\n    if (returnedBy !== 'userinfo') {\n      ['iss', 'sub', 'aud', 'exp', 'iat'].forEach(verifyPresence);\n    }\n\n    if (payload.iss !== undefined) {\n      assert.equal(this.issuer.issuer, payload.iss, 'unexpected iss value');\n    }\n\n    if (payload.iat !== undefined) {\n      assert.equal(typeof payload.iat, 'number', 'iat is not a number');\n      assert(payload.iat <= timestamp + this.CLOCK_TOLERANCE, 'id_token issued in the future');\n    }\n\n    if (payload.nbf !== undefined) {\n      assert.equal(typeof payload.nbf, 'number', 'nbf is not a number');\n      assert(payload.nbf <= timestamp + this.CLOCK_TOLERANCE, 'id_token not active yet');\n    }\n\n    if (maxAge || (maxAge !== null && this.require_auth_time)) {\n      assert(payload.auth_time, 'missing required JWT property auth_time');\n      assert.equal(typeof payload.auth_time, 'number', 'auth_time is not a number');\n    }\n\n    if (maxAge) {\n      assert(payload.auth_time + maxAge >= timestamp - this.CLOCK_TOLERANCE, 'too much time has elapsed since the last End-User authentication');\n    }\n\n    if (nonce !== null && (payload.nonce || nonce !== undefined)) {\n      assert.equal(payload.nonce, nonce, 'nonce mismatch');\n    }\n\n    if (payload.exp !== undefined) {\n      assert.equal(typeof payload.exp, 'number', 'exp is not a number');\n      assert(timestamp - this.CLOCK_TOLERANCE < payload.exp, 'id_token expired');\n    }\n\n    if (payload.aud !== undefined) {\n      if (!Array.isArray(payload.aud)) {\n        payload.aud = [payload.aud];\n      } else if (payload.aud.length > 1 && !payload.azp) {\n        throw new Error('missing required JWT property azp');\n      }\n    }\n\n    if (payload.azp !== undefined) {\n      assert.equal(this.client_id, payload.azp, 'azp must be the client_id');\n    }\n\n    if (payload.aud !== undefined) {\n      assert(payload.aud.indexOf(this.client_id) !== -1, 'aud is missing the client_id');\n    }\n\n    if (returnedBy === 'authorization') {\n      assert(payload.at_hash || !tokenSet.access_token, 'missing required property at_hash');\n      assert(payload.c_hash || !tokenSet.code, 'missing required property c_hash');\n    }\n\n    if (tokenSet.access_token && payload.at_hash !== undefined) {\n      assert(tokenHash(payload.at_hash, tokenSet.access_token), 'at_hash mismatch');\n    }\n\n    if (tokenSet.code && payload.c_hash !== undefined) {\n      assert(tokenHash(payload.c_hash, tokenSet.code), 'c_hash mismatch');\n    }\n\n    if (header.alg === 'none') {\n      return Promise.resolve(tokenSet);\n    }\n\n    return (header.alg.startsWith('HS') ? this.joseSecret() : this.issuer.key(header))\n      .then(key => jose.JWS.createVerify(key).verify(idToken).catch(() => {\n        throw new Error('invalid signature');\n      }))\n      .then(() => tokenSet);\n  }\n\n  /**\n   * @name refresh\n   * @api public\n   */\n  refresh(refreshToken) {\n    let token = refreshToken;\n\n    if (token instanceof TokenSet) {\n      if (!token.refresh_token) {\n        return Promise.reject(new Error('refresh_token not present in TokenSet'));\n      }\n      token = token.refresh_token;\n    }\n\n    return this.grant({\n      grant_type: 'refresh_token',\n      refresh_token: String(token),\n    })\n    .then((tokenset) => {\n      if (!tokenset.id_token) {\n        return tokenset;\n      }\n      return this.decryptIdToken(tokenset, 'id_token')\n        .then(() => this.validateIdToken(tokenset, null, 'token', null));\n    });\n  }\n\n  /**\n   * @name userinfo\n   * @api public\n   */\n  userinfo(accessToken, options) {\n    let token = accessToken;\n    const opts = _.merge({\n      verb: 'get',\n      via: 'header',\n    }, options);\n\n    if (token instanceof TokenSet) {\n      if (!token.access_token) {\n        return Promise.reject(new Error('access_token not present in TokenSet'));\n      }\n      token = token.access_token;\n    }\n\n    const verb = String(opts.verb).toLowerCase();\n    let httpOptions;\n\n    switch (opts.via) {\n      case 'query':\n        assert.equal(verb, 'get', 'providers should only parse query strings for GET requests');\n        httpOptions = { query: { access_token: token } };\n        break;\n      case 'body':\n        assert.equal(verb, 'post', 'can only send body on POST');\n        httpOptions = { body: { access_token: token } };\n        break;\n      default:\n        httpOptions = { headers: { Authorization: bearer(token) } };\n    }\n\n    return got[verb](this.issuer.userinfo_endpoint, this.issuer.httpOptions(httpOptions))\n      .then(expectResponse(200))\n      .then((response) => {\n        if (JWT_CONTENT.exec(response.headers['content-type'])) {\n          return Promise.resolve(response.body)\n            .then(jwt => this.decryptIdToken(jwt, 'userinfo'))\n            .then((jwt) => {\n              if (!this.userinfo_signed_response_alg) return JSON.parse(jwt);\n              return this.validateIdToken(jwt, null, 'userinfo', null)\n                .then(valid => JSON.parse(base64url.decode(valid.split('.')[1])));\n            });\n        }\n\n        return JSON.parse(response.body);\n      })\n      .then((parsed) => {\n        if (accessToken.id_token) {\n          assert.equal(getSub(accessToken.id_token), parsed.sub, 'userinfo sub mismatch');\n        }\n\n        return parsed;\n      })\n      .catch(errorHandler);\n  }\n\n  /**\n   * @name derivedKey\n   * @api private\n   */\n  derivedKey(len) {\n    const cacheKey = `${len}_key`;\n    if (instance(this)[cacheKey]) {\n      return Promise.resolve(instance(this)[cacheKey]);\n    }\n\n    const derivedBuffer = crypto.createHash('sha256')\n      .update(this.client_secret)\n      .digest()\n      .slice(0, len / 8);\n\n    return jose.JWK.asKey({ k: base64url(derivedBuffer), kty: 'oct' }).then((key) => {\n      instance(this)[cacheKey] = key;\n      return key;\n    });\n  }\n\n  /**\n   * @name joseSecret\n   * @api private\n   */\n  joseSecret(alg) {\n    if (String(alg).match(/^A(128|192|256)(GCM)?KW$/)) {\n      return this.derivedKey(RegExp.$1);\n    }\n\n    if (instance(this).jose_secret) {\n      return Promise.resolve(instance(this).jose_secret);\n    }\n\n    return jose.JWK.asKey({ k: base64url(this.client_secret), kty: 'oct' }).then((key) => {\n      instance(this).jose_secret = key;\n      return key;\n    });\n  }\n\n  /**\n   * @name grant\n   * @api public\n   */\n  grant(body) {\n    assert(this.issuer.token_endpoint, 'issuer must be configured with token endpoint');\n    return this.authenticatedPost('token', { body: _.omitBy(body, _.isUndefined) })\n      .then(response => new TokenSet(JSON.parse(response.body)));\n  }\n\n  /**\n   * @name revoke\n   * @api public\n   */\n  revoke(token, hint) {\n    assert(this.issuer.revocation_endpoint, 'issuer must be configured with revocation endpoint');\n    assert(!hint || typeof hint === 'string', 'hint must be a string');\n\n    const body = { token };\n    if (hint) body.token_type_hint = hint;\n    return this.authenticatedPost('revocation', { body })\n      .then((response) => {\n        if (response.body) {\n          return JSON.parse(response.body);\n        }\n        return {};\n      });\n  }\n\n  /**\n   * @name introspect\n   * @api public\n   */\n  introspect(token, hint) {\n    assert(this.issuer.introspection_endpoint, 'issuer must be configured with introspection endpoint');\n    assert(!hint || typeof hint === 'string', 'hint must be a string');\n\n    const body = { token };\n    if (hint) body.token_type_hint = hint;\n    return this.authenticatedPost('introspection', { body })\n      .then(expectResponse(200))\n      .then(response => JSON.parse(response.body));\n  }\n\n  /* eslint-disable no-underscore-dangle */\n  /**\n   * @name fetchDistributedClaims\n   * @api public\n   */\n  fetchDistributedClaims(claims, accessTokens) {\n    const distributedSources = _.pickBy(claims._claim_sources, def => !!def.endpoint);\n    const tokens = accessTokens || {};\n\n    return Promise.all(_.map(distributedSources, (def, sourceName) => {\n      const opts = {\n        headers: { Authorization: bearer(def.access_token || tokens[sourceName]) },\n      };\n\n      return got(def.endpoint, this.issuer.httpOptions(opts))\n        .then(response => claimJWT.call(this, response.body), errorHandler)\n        .then((data) => {\n          delete claims._claim_sources[sourceName];\n          _.forEach(claims._claim_names, assignClaim(claims, data, sourceName));\n        }).catch(assignErrSrc(sourceName));\n    })).then(() => cleanUpClaims(claims));\n  }\n\n  /**\n   * @name unpackAggregatedClaims\n   * @api public\n   */\n  unpackAggregatedClaims(claims) {\n    const aggregatedSources = _.pickBy(claims._claim_sources, def => !!def.JWT);\n\n    return Promise.all(_.map(aggregatedSources, (def, sourceName) => {\n      const decoded = claimJWT.call(this, def.JWT);\n\n      return decoded.then((data) => {\n        delete claims._claim_sources[sourceName];\n        _.forEach(claims._claim_names, assignClaim(claims, data, sourceName));\n      }).catch(assignErrSrc(sourceName));\n    })).then(() => cleanUpClaims(claims));\n  }\n  /* eslint-enable no-underscore-dangle */\n\n  /**\n   * @name authenticatedPost\n   * @api private\n   */\n  authenticatedPost(endpoint, httpOptions) {\n    return Promise.resolve(this.authFor(endpoint))\n      .then(auth => got.post(this.issuer[`${endpoint}_endpoint`], this.issuer.httpOptions(_.merge(httpOptions, auth)))\n      .catch(errorHandler));\n  }\n\n  /**\n   * @name createSign\n   * @api private\n   */\n  createSign() {\n    let alg = this.token_endpoint_auth_signing_alg;\n    switch (this.token_endpoint_auth_method) {\n      case 'client_secret_jwt':\n        return this.joseSecret().then((key) => {\n          if (!alg) {\n            alg = _.find(this.issuer.token_endpoint_auth_signing_alg_values_supported,\n              signAlg => key.algorithms('sign').indexOf(signAlg) !== -1);\n          }\n\n          return jose.JWS.createSign({\n            fields: { alg, typ: 'JWT' },\n            format,\n          }, { key, reference: false });\n        });\n      case 'private_key_jwt': {\n        if (!alg) {\n          const algz = _.chain(instance(this).keystore.all())\n            .map(key => key.algorithms('sign'))\n            .flatten()\n            .uniq()\n            .value();\n\n          alg = _.find(this.issuer.token_endpoint_auth_signing_alg_values_supported,\n            signAlg => algz.indexOf(signAlg) !== -1);\n        }\n\n        const key = instance(this).keystore.get({ alg, use: 'sig' });\n        assert(key, 'no valid key found');\n\n        return Promise.resolve(jose.JWS.createSign({\n          fields: { alg, typ: 'JWT' },\n          format,\n        }, { key, reference: true }));\n      }\n      /* istanbul ignore next */\n      default:\n        throw new Error('createSign only works for _jwt token auth methods');\n    }\n  }\n\n  /**\n   * @name authFor\n   * @api private\n   */\n  authFor(endpoint) {\n    switch (this.token_endpoint_auth_method) {\n      case 'none' :\n        throw new Error('client not supposed to use grant authz');\n      case 'client_secret_post':\n        return {\n          body: {\n            client_id: this.client_id,\n            client_secret: this.client_secret,\n          },\n        };\n      case 'private_key_jwt' :\n      case 'client_secret_jwt' : {\n        const timestamp = now();\n        return this.createSign().then(sign => sign.update(JSON.stringify({\n          iat: timestamp,\n          exp: timestamp + 60,\n          jti: uuid(),\n          iss: this.client_id,\n          sub: this.client_id,\n          aud: this.issuer[`${endpoint}_endpoint`],\n        })).final().then((client_assertion) => { // eslint-disable-line camelcase, arrow-body-style\n          return { body: {\n            client_assertion,\n            client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',\n          } };\n        }));\n      }\n      default: {\n        const value = new Buffer(`${this.client_id}:${this.client_secret}`).toString('base64');\n        return { headers: { Authorization: `Basic ${value}` } };\n      }\n    }\n  }\n\n\n  /**\n   * @name inspect\n   * @api public\n   */\n  inspect() {\n    return util.format('Client <%s>', this.client_id);\n  }\n\n  /**\n   * @name register\n   * @api public\n   */\n  static register(properties, opts) {\n    const options = (() => {\n      if (!opts) return {};\n      if (_.isPlainObject(opts)) return opts;\n      return { keystore: deprecatedKeystore(opts) };\n    })();\n\n    const keystore = options.keystore;\n    const initialAccessToken = options.initialAccessToken;\n\n    assert(this.issuer.registration_endpoint, 'issuer does not support dynamic registration');\n\n    if (keystore !== undefined && !(properties.jwks || properties.jwks_uri)) {\n      assert(jose.JWK.isKeyStore(keystore), 'keystore must be an instance of jose.JWK.KeyStore');\n      assert(keystore.all().every((key) => {\n        if (key.kty === 'RSA' || key.kty === 'EC') {\n          try { key.toPEM(true); } catch (err) { return false; }\n          return true;\n        }\n        return false;\n      }), 'keystore must only contain private EC or RSA keys');\n      properties.jwks = keystore.toJSON();\n    }\n\n    const headers = { 'Content-Type': 'application/json' };\n\n    if (initialAccessToken) headers.Authorization = `Bearer ${initialAccessToken}`;\n\n    return got.post(this.issuer.registration_endpoint, this.issuer.httpOptions({\n      headers,\n      body: JSON.stringify(properties),\n    }))\n    .then(expectResponse(201))\n    .then(response => new this(JSON.parse(response.body), keystore))\n    .catch(errorHandler);\n  }\n\n  get metadata() {\n    return instance(this).metadata;\n  }\n\n  /**\n   * @name fromUri\n   * @api public\n   */\n  static fromUri(uri, token) {\n    return got(uri, this.issuer.httpOptions({\n      headers: { Authorization: bearer(token) },\n    }))\n    .then(expectResponse(200))\n    .then(response => new this(JSON.parse(response.body)), errorHandler);\n  }\n\n  /**\n   * @name requestObject\n   * @api public\n   */\n  requestObject(input, algorithms) {\n    assert.equal(typeof input, 'object', 'pass an object as the first argument');\n    const request = input || {};\n    const algs = algorithms || {};\n\n    _.defaults(algs, {\n      sign: this.request_object_signing_alg,\n      encrypt: {\n        alg: this.request_object_encryption_alg,\n        enc: this.request_object_encryption_enc,\n      },\n    }, {\n      sign: 'none',\n    });\n\n    const signed = (() => {\n      const alg = algs.sign;\n      const header = { alg, typ: 'JWT' };\n      const payload = JSON.stringify(_.defaults({}, request, {\n        iss: this.client_id,\n        aud: this.issuer.issuer,\n        client_id: this.client_id,\n      }));\n\n      if (alg === 'none') {\n        return Promise.resolve([\n          base64url(JSON.stringify(header)),\n          base64url(payload),\n          '',\n        ].join('.'));\n      }\n\n      const symmetrical = alg.startsWith('HS');\n\n      const getKey = (() => {\n        if (symmetrical) return this.joseSecret();\n        const keystore = instance(this).keystore;\n\n        assert(keystore, `no keystore present for client, cannot sign using ${alg}`);\n        const key = keystore.get({ alg, use: 'sig' });\n        assert(key, `no key to sign with found for ${alg}`);\n        return Promise.resolve(key);\n      })();\n\n      return getKey\n        .then(key => jose.JWS.createSign({\n          fields: header,\n          format,\n        }, { key, reference: !symmetrical }))\n        .then(sign => sign.update(payload).final());\n    })();\n\n    if (!algs.encrypt.alg) return signed;\n    const fields = { alg: algs.encrypt.alg, enc: algs.encrypt.enc, cty: 'JWT' };\n\n    /* eslint-disable arrow-body-style */\n    return this.issuer.key({\n      alg: algs.encrypt.alg,\n      enc: algs.encrypt.enc,\n      use: 'enc',\n    }, true).then((key) => {\n      return signed.then((cleartext) => {\n        return jose.JWE.createEncrypt({ format, fields }, { key })\n          .update(cleartext)\n          .final();\n      });\n    });\n    /* eslint-enable arrow-body-style */\n  }\n}\n\nObject.defineProperty(Client.prototype, 'grantAuth', {\n  get: util.deprecate(/* istanbul ignore next */ function grantAuth() {\n    return this.authFor('token');\n  }, 'client#grantAuth is deprecated'),\n});\n\nmodule.exports = Client;\n","/home/travis/build/npmtest/node-npmtest-openid-client/node_modules/openid-client/lib/expect_response.js":"'use strict';\n\nconst assert = require('assert');\nconst STATUS_CODES = require('http').STATUS_CODES;\n\nmodule.exports = function generateExpectResponseBody(statusCode) {\n  return function expectResponseBody(response) {\n    assert(response.body,\n      `expected ${statusCode} ${STATUS_CODES[statusCode]} with body, got ${response.statusCode} ${STATUS_CODES[response.statusCode]} without one`);\n    return response;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-openid-client/node_modules/openid-client/lib/token_set.js":"'use strict';\n\nconst now = require('./unix_timestamp');\nconst base64url = require('base64url');\n\nconst decodedClaims = new WeakMap();\n\nclass TokenSet {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(values) {\n    Object.assign(this, values);\n  }\n\n  /**\n   * @name expires_in=\n   * @api public\n   */\n  set expires_in(value) { // eslint-disable-line camelcase\n    this.expires_at = now() + Number(value);\n  }\n\n  /**\n   * @name expires_in\n   * @api public\n   */\n  get expires_in() { // eslint-disable-line camelcase\n    return Math.max.apply(null, [this.expires_at - now(), 0]);\n  }\n\n  /**\n   * @name expired\n   * @api public\n   */\n  expired() {\n    return this.expires_in === 0;\n  }\n\n  /**\n   * @name claims\n   * @api public\n   */\n  get claims() {\n    if (decodedClaims.has(this)) return decodedClaims.get(this);\n    if (!this.id_token) throw new Error('id_token not present in TokenSet');\n\n    const decoded = JSON.parse(base64url.decode(this.id_token.split('.')[1]));\n    decodedClaims.set(this, decoded);\n    return decoded;\n  }\n}\n\nmodule.exports = TokenSet;\n","/home/travis/build/npmtest/node-npmtest-openid-client/node_modules/openid-client/lib/unix_timestamp.js":"module.exports = () => Date.now() / 1000 | 0; // eslint-disable-line no-bitwise\n","/home/travis/build/npmtest/node-npmtest-openid-client/node_modules/openid-client/lib/issuer_registry.js":"'use strict';\n\nconst REGISTRY = new Map();\n\nmodule.exports = REGISTRY;\n","/home/travis/build/npmtest/node-npmtest-openid-client/node_modules/openid-client/lib/webfinger_normalize.js":"'use strict';\n\n// Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py\n\n// -- Normalization --\n// A string of any other type is interpreted as a URI either the form of scheme\n// \"://\" authority path-abempty [ \"?\" query ] [ \"#\" fragment ] or authority\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986] and is\n// normalized according to the following rules:\n//\n// If the user input Identifier does not have an RFC 3986 [RFC3986] scheme\n// portion, the string is interpreted as [userinfo \"@\"] host [\":\" port]\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986].\n// If the userinfo component is present and all of the path component, query\n// component, and port component are empty, the acct scheme is assumed. In this\n// case, the normalized URI is formed by prefixing acct: to the string as the\n// scheme. Per the 'acct' URI Scheme [I‑D.ietf‑appsawg‑acct‑uri], if there is an\n// at-sign character ('@') in the userinfo component, it needs to be\n// percent-encoded as described in RFC 3986 [RFC3986].\n// For all other inputs without a scheme portion, the https scheme is assumed,\n// and the normalized URI is formed by prefixing https:// to the string as the\n// scheme.\n// If the resulting URI contains a fragment portion, it MUST be stripped off\n// together with the fragment delimiter character \"#\".\n// The WebFinger [I‑D.ietf‑appsawg‑webfinger] Resource in this case is the\n// resulting URI, and the WebFinger Host is the authority component.\n//\n// Note: Since the definition of authority in RFC 3986 [RFC3986] is\n// [ userinfo \"@\" ] host [ \":\" port ], it is legal to have a user input\n// identifier like userinfo@host:port, e.g., alice@example.com:8080.\n\nconst assert = require('assert');\n\nconst PORT = /^\\d+$/;\n\nfunction hasScheme(input) {\n  if (input.includes('://')) return true;\n\n  const authority = input.replace(/(\\/|\\?)/g, '#').split('#')[0];\n  if (authority.includes(':')) {\n    const index = authority.indexOf(':');\n    const hostOrPort = authority.slice(index + 1);\n    if (!PORT.exec(hostOrPort)) return true;\n  }\n\n  return false;\n}\n\nfunction acctSchemeAssumed(input) {\n  if (!input.includes('@')) return false;\n  const parts = input.split('@');\n  const host = parts[parts.length - 1];\n  return !(host.includes(':') || host.includes('/') || host.includes('?'));\n}\n\nfunction normalize(input) {\n  assert(input, 'nothing to normalize');\n  assert.equal(typeof input, 'string', 'input must be a string');\n\n  let output;\n  if (hasScheme(input)) {\n    output = input;\n  } else if (acctSchemeAssumed(input)) {\n    output = `acct:${input}`;\n  } else {\n    output = `https://${input}`;\n  }\n\n  return output.split('#')[0];\n}\n\nmodule.exports = normalize;\n","/home/travis/build/npmtest/node-npmtest-openid-client/node_modules/openid-client/lib/passport_strategy.js":"'use strict';\n\n/* eslint-disable no-underscore-dangle */\n\nconst _ = require('lodash');\nconst uuid = require('uuid');\nconst url = require('url');\nconst assert = require('assert');\nconst OpenIdConnectError = require('./open_id_connect_error');\nconst Client = require('./client');\n\nfunction verified(err, user, info) {\n  const add = info || {};\n  if (err) {\n    this.error(err);\n  } else if (!user) {\n    this.fail(add);\n  } else {\n    this.success(user, add);\n  }\n}\n\n/**\n * @name constructor\n * @api public\n */\nfunction OpenIDConnectStrategy(options, verify) {\n  const opts = (() => {\n    if (options instanceof Client) return { client: options };\n    return options;\n  })();\n\n  const client = opts.client;\n\n  assert.equal(client instanceof Client, true);\n  assert.equal(typeof verify, 'function');\n\n  assert(client.issuer && client.issuer.issuer, 'client must have an issuer with an identifier');\n\n  this._client = client;\n  this._issuer = client.issuer;\n  this._verify = verify;\n  this._params = opts.params || {};\n  const params = this._params;\n\n  this.name = url.parse(client.issuer.issuer).hostname;\n\n  if (!params.response_type) params.response_type = _.get(client, 'response_types[0]', 'code');\n  if (!params.redirect_uri) params.redirect_uri = _.get(client, 'redirect_uris[0]');\n  if (!params.scope) params.scope = 'openid';\n}\n\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n  const client = this._client;\n  const issuer = this._issuer;\n  try {\n    if (!req.session) throw new Error('authentication requires session support when using state, max_age or nonce');\n    const reqParams = client.callbackParams(req);\n    const sessionKey = `oidc:${url.parse(issuer.issuer).hostname}`;\n\n    /* start authentication request */\n    if (_.isEmpty(reqParams)) {\n      // provide options objecti with extra authentication parameters\n      const opts = _.defaults({}, options, this._params, {\n        state: uuid(),\n      });\n\n      if (!opts.nonce && opts.response_type.includes('id_token')) {\n        opts.nonce = uuid();\n      }\n\n      req.session[sessionKey] = _.pick(opts, 'nonce', 'state', 'max_age');\n      this.redirect(client.authorizationUrl(opts));\n      return;\n    }\n    /* end authentication request */\n\n    /* start authentication response */\n    const session = req.session[sessionKey];\n    const state = _.get(session, 'state');\n    const maxAge = _.get(session, 'max_age');\n    const nonce = _.get(session, 'nonce');\n\n    if (req.session) delete req.session[sessionKey];\n\n    const opts = _.defaults({}, options, {\n      redirect_uri: this._params.redirect_uri,\n    });\n\n    const checks = { state, nonce, max_age: maxAge };\n    let callback = client.authorizationCallback(opts.redirect_uri, reqParams, checks)\n      .then((tokenset) => {\n        const result = { tokenset };\n        return result;\n      });\n\n    const loadUserinfo = this._verify.length > 2 && client.issuer.userinfo_endpoint;\n\n    if (loadUserinfo) {\n      callback = callback.then((result) => {\n        if (result.tokenset.access_token) {\n          const userinfoRequest = client.userinfo(result.tokenset);\n          return userinfoRequest.then((userinfo) => {\n            result.userinfo = userinfo;\n            return result;\n          });\n        }\n\n        return result;\n      });\n    }\n\n    callback.then((result) => {\n      if (loadUserinfo) {\n        this._verify(result.tokenset, result.userinfo, verified.bind(this));\n      } else {\n        this._verify(result.tokenset, verified.bind(this));\n      }\n    }).catch((error) => {\n      if (error instanceof OpenIdConnectError &&\n            error.error !== 'server_error' &&\n            !error.error.startsWith('invalid')) {\n        this.fail(error);\n      } else {\n        this.error(error);\n      }\n    });\n    /* end authentication response */\n  } catch (err) {\n    this.error(err);\n  }\n};\n\nmodule.exports = OpenIDConnectStrategy;\n"}